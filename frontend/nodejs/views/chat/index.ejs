<head>
    <link rel="stylesheet" type="text/css" href="/css/chat/chatPage.css" />
</head>
<h1>Chat with AI</h1>

<form id="chat-form">
    <input type="text" id="prompt" name="prompt" placeholder="Message the AI" required>
    <button type="submit">Send</button>
</form>

<div id="chat-output"></div>

<script>
    /*
    * Function to process the full AI content.
    * It wraps text outside of <think> tags in <pre> elements
    * and wraps content inside <think> tags in collapsible <details> boxes.
    */
    function processAIContent(content) {
        if (content.indexOf("<think>") === -1) return "<pre>" + content + "</pre>";

        let result = "";
        let remaining = content;

        while (true) {
            let openIndex = remaining.indexOf("<think>");
            if (openIndex === -1) {
                if (remaining) {
                    result += "<pre>" + remaining + "</pre>";
                }
                break;
            }
            // Wrap text before the <think> tag in <pre> tags.
            let outsideText = remaining.substring(0, openIndex);
            if (outsideText) {
                result += "<pre>" + outsideText + "</pre>";
            }
            // Remove the opening <think> tag.
            remaining = remaining.substring(openIndex + 7); // 7 chars for "<think>"

            // Look for the closing tag.
            let closeIndex = remaining.indexOf("</think>");
            if (closeIndex === -1) {
                // Unclosed think tag: wrap everything in an open details box.
                result += `<details class="ai-think" open><summary>Thoughts</summary><div><pre>` +
                    remaining + `</pre></div></details>`;
                remaining = "";
                break;
            } else {
                // Closed think block: wrap inner content in details.
                let innerContent = remaining.substring(0, closeIndex);

                // Check if the inner content is only whitespace or empty
                const isEmpty = !innerContent.trim();

                if (isEmpty) {
                    result += `<details class="ai-think" style="display: none"><summary>Thoughts</summary><div><pre>` +
                        innerContent + `</pre></div></details>`;
                } else {
                    result += `<details class="ai-think"><summary>Thoughts</summary><div><pre>` +
                        innerContent + `</pre></div></details>`;
                }

                // Move past the closing tag (8 chars for "</think>")
                remaining = remaining.substring(closeIndex + 8);
            }
        }
        return result;
    }

    $(document).ready(function () {
        $('#chat-form').on('submit', function (e) {
            e.preventDefault();

            let prompt = $('#prompt').val();
            $('#prompt').val("");

            // Generate a unique ID for the AI response so it can be tracked with response streaming
            const messageId = 'ai-response-' + Date.now();

            // Append the user message and an empty container for the AI response.
            $('#chat-output').append(`
                <div class="chat-message user-message">
                    <strong>You:</strong>
                    <pre>${prompt}</pre>
                </div>
                <div id="${messageId}" class="chat-message ai-response">
                    <strong>AI:</strong>
                    <div class="ai-content"></div>
                </div>
            `);

            const container = document.querySelector(`#${messageId} .ai-content`);
            const eventSource = new EventSource(`/chat/getChatResponse?prompt=${encodeURIComponent(prompt)}`);

            let aiResponse = ''; // Accumulates the entire response.
            let currentAppendTarget = null; // Pointer to the current <pre> element for plain text.

            // Reprocesses the entire accumulated content and sets the append target.
            function reprocessAndUpdate() {
                container.innerHTML = processAIContent(aiResponse);
                let candidate = container.querySelector('pre:last-of-type');
                if (candidate) {
                    // If the candidate is inside a closed think block, create a new <pre>.
                    let detailsParent = candidate.closest('details.ai-think');
                    if (detailsParent && !detailsParent.hasAttribute('open')) {
                        let newPre = document.createElement('pre');
                        container.appendChild(newPre);
                        currentAppendTarget = newPre;
                    } else {
                        currentAppendTarget = candidate;
                    }
                } else {
                    let newPre = document.createElement('pre');
                    container.appendChild(newPre);
                    currentAppendTarget = newPre;
                }
            }

            function updateAppendTarget(newText) {
                if (!currentAppendTarget) {
                    let newPre = document.createElement('pre');
                    container.appendChild(newPre);
                    currentAppendTarget = newPre;
                }
                // Accumulate and trim the entire content
                currentAppendTarget.textContent = currentAppendTarget.textContent + newText;
                currentAppendTarget.textContent = currentAppendTarget.textContent.trimStart();
            }


            eventSource.onmessage = function (event) {
                if (event.data === "[DONE]") {
                    eventSource.close();
                    return;
                }
                try {
                    const rawData = event.data.trim().startsWith("data: ")
                        ? event.data.substring(5)
                        : event.data;
                    if (rawData) {
                        const responseData = JSON.parse(rawData);
                        const content = responseData.choices[0].delta.content;
                        aiResponse += content;

                        // If the incoming chunk contains a think tag (opening or closing),
                        // reprocess the full accumulated response.
                        if (content.indexOf("<think>") !== -1 || content.indexOf("</think>") !== -1) {
                            reprocessAndUpdate();
                        } else {
                            // Otherwise, just update the current append target.
                            updateAppendTarget(content);
                        }
                        $('#chat-output').scrollTop($('#chat-output')[0].scrollHeight);
                    }
                } catch (e) {
                    console.error("Error parsing response:", e);
                }
            };

            eventSource.onerror = function () {
                alert('An error occurred while streaming the response.');
                eventSource.close();
            };
        });
    });
</script>
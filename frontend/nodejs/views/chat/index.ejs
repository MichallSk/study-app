<head>
  <link rel="stylesheet" type="text/css" href="/css/chat/chatPage.css" />
</head>
<h1>Chat with AI</h1>

<form id="chat-form">
  <textarea id="prompt" name="prompt" placeholder="Message the AI" rows="1" required></textarea>
  <button type="submit">Send</button>
</form>

<div id="chat-output"></div>

<script>
  // Configure marked options
  marked.setOptions({
    breaks: true,      // Convert \n to <br>
    gfm: true,         // GitHub flavored markdown
    headerIds: false,  // Don't add ids to headers
    sanitize: true    // Prevent script injection
  });

  // Process AI content, separating <think> tags from visible content
  function processAIContent(content) {

    /**
     * Think match section
     * Uses regex to match all content within think tags
     * Regex also matches content to the end if the think tag does not have a closing tag.
     */
    const thinkMatch = content.match(/<think>([\s\S]*?)(?:<\/think>|$)/);
    if (!thinkMatch) {
      return {
        thoughts: "",
        visible: content
      };
    }
    const thoughtContent = thinkMatch[1];
    let visibleContent = content.replace(/<think>[\s\S]*?(?:<\/think>|$)/, "");
    return {
      thoughts: thoughtContent,
      visible: visibleContent
    };
  }

  // Render the entire AI response from the server-side processed content
  function renderFullResponse(fullRawContent, container) {
    const processedContent = processAIContent(fullRawContent);
    container.innerHTML = '';

    /**
     * Styling Section, takes the processed content and splits it into
     * pre tags and summary/details tags
     */

    // Styles the content inside of the <think></think> tags
    if (processedContent.thoughts.trim()) {
      const detailsElement = document.createElement('details');
      detailsElement.className = 'ai-think';
      detailsElement.setAttribute('open', '');
      const summaryElement = document.createElement('summary');
      summaryElement.textContent = 'Thoughts';
      detailsElement.appendChild(summaryElement);
      const innerDiv = document.createElement('div');
      innerDiv.className = 'markdown-content';
      innerDiv.innerHTML = marked.parse(processedContent.thoughts);
      detailsElement.appendChild(innerDiv);
      container.appendChild(detailsElement);
    }

        // Styles the content outside of the <think></think> tags
    if (processedContent.visible) {
      const visibleContentDiv = document.createElement('div');
      visibleContentDiv.className = 'markdown-content';
      visibleContentDiv.innerHTML = marked.parse(processedContent.visible);
      container.appendChild(visibleContentDiv);
    }
  }

  // Escape HTML entities to prevent script injection
  function escapeHTML(str) {
    return str.replace(/[&<>"']/g, function(match) {
      const escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      return escapeMap[match];
    });
  }

  // Append the user's prompt and an empty AI response container to the chat output
  function appendChatMessages(prompt) {
    const messageId = 'ai-response-' + Date.now();
    $('#chat-output').append(`
      <div class="chat-message user-message">
        <strong>You:</strong>
        <pre>${escapeHTML(prompt)}</pre>
      </div>
      <div id="${messageId}" class="chat-message ai-response">
        <strong>AI:</strong>
        <div class="ai-content"></div>
      </div>
    `);
    return document.querySelector(`#${messageId} .ai-content`);
  }

  // Scroll the chat output to the bottom
  function updateScroll() {
    $('#chat-output').scrollTop($('#chat-output')[0].scrollHeight);
  }

  $(document).ready(function () {
    $('#chat-form').on('submit', function (e) {
      e.preventDefault();
      const prompt = $('#prompt').val();
      $('#prompt').val("");
      adjustTextareaHeight($('#prompt')[0]);

      // Append the messages and set up the container.
      const container = appendChatMessages(prompt);

      // Create an EventSource for SSE.
      const eventSource = new EventSource(`/chat/getChatResponse?prompt=${encodeURIComponent(prompt)}`);

      /**
       * Processing Section
       * handles the incoming messages from the server-side code
       */
      
       // Listens for messages sent through the stream and displays them on the webpage
       eventSource.onmessage = function (event) {
        if (event.data === "[DONE]") {
          eventSource.close();
          return;
        }
        try {
          const data = JSON.parse(event.data);
          renderFullResponse(data.fullContent, container);
          updateScroll();
        } catch (e) {
          console.error("Error parsing server update:", e);
        }
      };

      // Listens for errors that occurred through the stream and closes it if encountering
      eventSource.onerror = function () {
        alert('An error occurred while streaming the response.');
        eventSource.close();
      };
    });

    // Adjust the height of the textarea to fit its content
    function adjustTextareaHeight(textarea) {
      // Reset the height to auto so we can measure the new content height
      textarea.style.height = 'auto';

      // Set the height to the scrollHeight, which will adjust according to content
      textarea.style.height = textarea.scrollHeight + 'px';
    }

    // Handle keydown event to adjust height and submit on Enter
    $('#prompt').on('keydown', function (e) {
      adjustTextareaHeight(this);
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        $('#chat-form').submit();
      }
    });

    // Handle input event to adjust height
    $('#prompt').on('input', function () {
      adjustTextareaHeight(this);
    });

    // Initially set the textarea height
    adjustTextareaHeight($('#prompt')[0]);
  });
</script>
<head>
  <link rel="stylesheet" type="text/css" href="/css/chat/chatPage.css" />
  <%- include(chat/math') %> <!-- includes math logic -->
</head>
<h1>Chat with AI</h1>

<div id="settings-container">
  <div id="settings-toggle">Settings</div>
  <div id="settings-dropdown" style="display: none;">
    <!-- Chat Mode Segment (reserved) -->
    <div class="segment-group">
      <span class="segment-group-heading">Chat Mode:</span>
      <label>
        <input type="radio" name="mode" value="default" checked> Normal
      </label>
      <label>
        <input type="radio" name="mode" value="steps"> Explain in Steps
      </label>
      <label>
        <input type="radio" name="mode" value="example"> Real World Example
      </label>
      <label>
        <input type="radio" name="mode" value="flashcards"> Generate Flashcards
      </label>
    </div>
    <!-- New Thoughts Default Segment -->
    <div class="segment-group">
      <span class="segment-group-heading">Thoughts Tag Default:</span>
      <label>
        <input type="radio" name="thoughtsDefault" value="open" checked> Open
      </label>
      <label>
        <input type="radio" name="thoughtsDefault" value="closed"> Closed
      </label>
    </div>
  </div>
</div>

<!--Hidden but stores selected mode-->
<form id="chat-form">
  <textarea id="prompt" name="prompt" placeholder="Message the AI" rows="1" required></textarea>
  <input type="hidden" id="response-mode" name="mode" value="default">
  <button type="submit">Send</button>
</form>

<div id="chat-output"></div>

  // Process AI content, separating <think> tags from visible content
  function processAIContent(content) {

    /**
     * Think match section
     * Uses regex to match all content within think tags
     * Regex also matches content to the end if the think tag does not have a closing tag.
     */
    const thinkMatch = content.match(/<think>([\s\S]*?)(?:<\/think>|$)/);
    if (!thinkMatch) {
      return {
        thoughts: "",
        visible: content
      };
    }
    const thoughtContent = thinkMatch[1];
    let visibleContent = content.replace(/<think>[\s\S]*?(?:<\/think>|$)/, "");
    return {
      thoughts: thoughtContent,
      visible: visibleContent
    };
  }

  // Render the entire AI response from the server-side processed content
  function renderFullResponse(fullRawContent, container, isFinal = false) {
    const processedContent = processAIContent(fullRawContent);
    // Retrieve the current default from settings.
    const thoughtsDefault = $('input[name="thoughtsDefault"]:checked').val();
    // If no persisted state is set, initialize it from the default setting.
    if (typeof window.persistedThoughtsState === 'undefined') {
      window.persistedThoughtsState = (thoughtsDefault === 'open');
    }

    container.innerHTML = '';

    /**
     * Styling Section, takes the processed content and splits it into
     * pre tags and summary/details tags
     */

    // Styles the content inside of the <think></think> tags
    if (processedContent.thoughts.trim()) {
      const detailsElement = document.createElement('details');
      detailsElement.className = 'ai-think';
      // Use the persisted state rather than re-setting from the default every time.
      if (window.persistedThoughtsState) {
        detailsElement.setAttribute('open', '');
      }
      const summaryElement = document.createElement('summary');
      summaryElement.textContent = isFinal ? 'Thoughts' : 'Thinking...';
      detailsElement.appendChild(summaryElement);

      const innerDiv = document.createElement('div');
      innerDiv.className = 'markdown-content';
      innerDiv.innerHTML = processMathContent(processedContent.thoughts);
      detailsElement.appendChild(innerDiv);
      container.appendChild(detailsElement);

      // When the user toggles the details element, update the persisted state.
      detailsElement.addEventListener('toggle', function () {
        window.persistedThoughtsState = detailsElement.open;
      });
    }

    // Styles the content outside of the <think></think> tags
    if (processedContent.visible) {
      const visibleContentDiv = document.createElement('div');
      visibleContentDiv.className = 'markdown-content';
      visibleContentDiv.innerHTML = processMathContent(processedContent.visible);
      container.appendChild(visibleContentDiv);
    }

    // Trigger MathJax once, after all content is added
    if (typeof MathJax !== 'undefined') {
      MathJax.typesetPromise([container]).catch(function (err) {
        console.error('MathJax typeset failed: ', err);
      });
    }
  }

  // Escape HTML entities to prevent script injection
  function escapeHTML(str) {
    return str.replace(/[&<>"']/g, function (match) {
      const escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      return escapeMap[match];
    });
  }

  // Append the user's prompt and an empty AI response container to the chat output
  function appendChatMessages(prompt, mode) {
    const messageId = 'ai-response-' + Date.now();
    const modeText = $('input[name="mode"]:checked').closest("label").text().trim(); // Get the label of the selected radio button

    $('#chat-output').append(`
        <div class="chat-message user-message">
          <div class="chatboxHeader"><span>You (${modeText}):</span></div>
          <pre>${escapeHTML(prompt)}</pre>
        </div>
        <div id="${messageId}" class="chat-message ai-response">
          <div class="chatboxHeader"><span>AI (${modeText}):</span></div>
          <div class="ai-content"></div>
        </div>
      `);
    return document.querySelector(`#${messageId} .ai-content`);
  }

  // Function to check if the user is near the bottom of the container
  function isUserNearBottom(threshold = 100) {
    const chatOutput = $('#chat-output')[0];
    const scrollPosition = chatOutput.scrollTop;
    const scrollHeight = chatOutput.scrollHeight;
    const clientHeight = chatOutput.clientHeight;

    // Check if the user is within 100px of the bottom of the container
    return scrollHeight - scrollPosition - clientHeight <= threshold;
  }

  // Update scroll behavior: only scroll if the user is near the bottom or when the scrollbar first appears
  function updateScroll(threshold = 100) {
    const chatOutput = $('#chat-output')[0];
    const scrollHeight = chatOutput.scrollHeight;
    const clientHeight = chatOutput.clientHeight;

    // Check if there's a scrollbar (i.e., the content is overflowing)
    const hasScrollbar = scrollHeight > clientHeight;

    // If the user is near the bottom or if there's no scrollbar, auto-scroll to the bottom
    if (hasScrollbar && isUserNearBottom(threshold)) {
      chatOutput.scrollTop = scrollHeight; // Scroll to the bottom
    } else if (!hasScrollbar) {
      // If there's no scrollbar, scroll to the bottom the first time content overflows
      chatOutput.scrollTop = scrollHeight;
    }
  }

  $(document).ready(function () {
    // Toggle dropdown settings menu
    $('#settings-toggle').on('click', function (e) {
      e.stopPropagation();
      const $dropdown = $('#settings-dropdown');

      if ($dropdown.is(':visible')) {
        $dropdown.slideUp();
      } else {
        $dropdown.slideDown({
          start: function () {
            $(this).css('display', 'flex');
          }
        });
      }
    });

    $(document).on('click', function (event) {
      if (!$(event.target).closest('#settings-container').length) {
        $('#settings-dropdown').slideUp();
      }
    });

    //Handle mode selection
    $('#settings-dropdown input[type="radio"]').on('change', function () {
      const selectedMode = $(this).val();
      $('#response-mode').val(selectedMode);

      $("#prompt").attr("placeholder", `Message the AI (${$('input[name="mode"]:checked').closest("label").text().trim()})`);
    });
    $("#prompt").attr("placeholder", `Message the AI (${$('input[name="mode"]:checked').closest("label").text().trim()})`);

    $('#chat-form').on('submit', function (e) {
      e.preventDefault();
      const prompt = $('#prompt').val();
      // Read the two separate radio groups:
      const chatMode = $('input[name="mode"]:checked').val();
      const thoughtsDefault = $('input[name="thoughtsDefault"]:checked').val();

      $('#prompt').val("");
      adjustTextareaHeight($('#prompt')[0]);

      // Append the messages and set up the container.
      // Use the chat mode for the display label.
      const modeText = $('input[name="mode"]:checked').closest("label").text().trim();
      const messageId = 'ai-response-' + Date.now();
      $('#chat-output').append(`
    <div class="chat-message user-message">
      <div class="chatboxHeader"><span>You (${modeText}):</span></div>
      <pre>${escapeHTML(prompt)}</pre>
    </div>
    <div id="${messageId}" class="chat-message ai-response">
      <div class="chatboxHeader"><span>AI (${modeText}):</span></div>
      <div class="ai-content"></div>
    </div>
  `);
      updateScroll(300);
      const container = document.querySelector(`#${messageId} .ai-content`);

      var lastFullContent = '';
      var receivedLength = 0;

      $.ajax({
        url: '/chat/getChatResponse',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({ prompt: prompt, mode: chatMode }),
        xhr: function () {
          var xhr = new window.XMLHttpRequest();
          xhr.responseType = 'text';
          xhr.addEventListener('progress', function () {
            // Get the new chunk from the response text
            var chunk = xhr.responseText.substring(receivedLength);
            receivedLength = xhr.responseText.length;
            var lines = chunk.split('\n');
            for (var i = 0; i < lines.length; i++) {
              if (lines[i].indexOf("data: ") === 0) {
                var jsonPart = lines[i].substring(6);
                if (jsonPart === "[DONE]") continue;
                if (jsonPart.trim().endsWith('"}')) {
                  try {
                    var parsedData = JSON.parse(jsonPart);
                    if (parsedData.fullContent) {
                      lastFullContent = parsedData.fullContent;
                      renderFullResponse(lastFullContent, container, false);
                      updateScroll();
                    }
                  } catch (e) {
                    console.error("Error parsing streamed data:", jsonPart);
                  }
                }
              }
            }
          });
          xhr.addEventListener('loadend', function () {
            renderFullResponse(lastFullContent, container, true);
          });
          return xhr;
        },
        error: function (err) {
          alert('An error occurred while streaming the response.');
          console.error(err);
        }
      });
    });

    // Adjust the height of the textarea to fit its content
    function adjustTextareaHeight(textarea) {
      // Reset the height to auto so we can measure the new content height
      textarea.style.height = 'auto';

      // Set the height to the scrollHeight, which will adjust according to content
      textarea.style.height = textarea.scrollHeight + 'px';
    }

    // Handle keydown event to adjust height and submit on Enter
    $('#prompt').on('keydown', function (e) {
      adjustTextareaHeight(this);
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        $('#chat-form').submit();
      }
    });

    // Handle input event to adjust height
    $('#prompt').on('input', function () {
      adjustTextareaHeight(this);
    });

    // Initially set the textarea height
    adjustTextareaHeight($('#prompt')[0]);
  });
</script>
